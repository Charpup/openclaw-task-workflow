/**
 * Subagent Progress Monitor - 10-minute reporting system
 * For future development tasks
 */

const fs = require('fs').promises;
const path = require('path');

class SubagentProgressMonitor {
  constructor(options = {}) {
    this.config = {
      taskId: options.taskId,
      taskName: options.taskName,
      progressFile: options.progressFile,
      reportIntervalMs: options.reportIntervalMs || 10 * 60 * 1000, // 10 minutes
      discordChannel: options.discordChannel || 'discord',
      ...options
    };
    this.startTime = Date.now();
    this.lastReportTime = 0;
    this.phase = 'init';
    this.completion = 0;
  }

  /**
   * Initialize progress tracking
   */
  async init() {
    await this.createProgressFile();
    await this.report('Task started', 'in_progress');
  }

  /**
   * Create progress file following task-workflow naming convention
   */
  async createProgressFile() {
    const template = `# Task Progress: ${this.config.taskName}

**Task ID:** ${this.config.taskId}  
**Status:** in_progress  
**Started:** ${new Date().toISOString()}  
**Next Report:** ${new Date(Date.now() + this.config.reportIntervalMs).toISOString()}

## Progress Summary
- Phase: init
- Completion: 0%
- ETA: Calculating...

## Activity Log
- [${new Date().toISOString()}] Task initialized

## Blockers
- None

## Next Steps
1. Execute phase 1
2. Continue monitoring

---

*Auto-generated by SubagentProgressMonitor*
`;

    await fs.writeFile(this.config.progressFile, template);
  }

  /**
   * Update progress (call this periodically)
   */
  async update(options = {}) {
    const now = Date.now();
    const elapsed = now - this.startTime;
    
    // Update internal state
    this.phase = options.phase || this.phase;
    this.completion = options.completion || this.completion;

    // Check if it's time to report
    if (now - this.lastReportTime >= this.config.reportIntervalMs) {
      await this.report(
        options.message || `Phase: ${this.phase}, Completion: ${this.completion}%`,
        'in_progress'
      );
      this.lastReportTime = now;
    }

    // Update progress file
    await this.updateProgressFile(options);
  }

  /**
   * Update progress file
   */
  async updateProgressFile(options = {}) {
    const content = await fs.readFile(this.config.progressFile, 'utf-8');
    const now = new Date().toISOString();
    
    // Update summary section
    let updated = content.replace(
      /- Phase: .*/,
      `- Phase: ${this.phase}`
    ).replace(
      /- Completion: .*/,
      `- Completion: ${this.completion}%`
    ).replace(
      /\*\*Next Report:\*\* .*/,
      `**Next Report:** ${new Date(Date.now() + this.config.reportIntervalMs).toISOString()}`
    );

    // Add activity log entry
    if (options.message) {
      updated = updated.replace(
        /## Activity Log/,
        `## Activity Log\n- [${now}] ${options.message}`
      );
    }

    // Update blockers
    if (options.blockers) {
      const blockersList = options.blockers.map(b => `- [ ] ${b}`).join('\n');
      updated = updated.replace(
        /## Blockers\n- .*/,
        `## Blockers\n${blockersList}`
      );
    }

    await fs.writeFile(this.config.progressFile, updated);
  }

  /**
   * Report to Discord (via sessions_send or message tool)
   */
  async report(message, status) {
    const report = {
      taskId: this.config.taskId,
      taskName: this.config.taskName,
      status,
      phase: this.phase,
      completion: this.completion,
      elapsed: Math.floor((Date.now() - this.startTime) / 1000),
      message,
      timestamp: new Date().toISOString()
    };

    // In subagent, use sessions_send to report to main session
    // This would be called via the appropriate tool
    console.log(`[REPORT] ${status}: ${message}`);
    
    return report;
  }

  /**
   * Mark task as completed
   */
  async complete(finalMessage = 'Task completed successfully') {
    this.completion = 100;
    this.phase = 'completed';
    
    await this.updateProgressFile({
      message: finalMessage
    });
    
    await this.report(finalMessage, 'completed');
    
    // Update file status
    const content = await fs.readFile(this.config.progressFile, 'utf-8');
    const updated = content.replace(
      /\*\*Status:\*\* .*/,
      '**Status:** completed'
    );
    await fs.writeFile(this.config.progressFile, updated);
  }

  /**
   * Main monitoring loop (to be called by subagent)
   */
  async monitorLoop(workFunction) {
    await this.init();
    
    try {
      await workFunction(this);
      await this.complete();
    } catch (error) {
      await this.report(`Error: ${error.message}`, 'error');
      throw error;
    }
  }
}

module.exports = SubagentProgressMonitor;

// Usage example for subagent:
/*
const monitor = new SubagentProgressMonitor({
  taskId: '001',
  taskName: 'Schema Sync',
  progressFile: '/root/.openclaw/workspace/01_active/tasks/task_001_schema_sync_progress.md'
});

await monitor.monitorLoop(async (m) => {
  // Phase 1
  m.update({ phase: 'research', completion: 25, message: 'Starting research' });
  await doResearch();
  
  // Phase 2
  m.update({ phase: 'implementation', completion: 50, message: 'Implementing' });
  await doImplementation();
  
  // Phase 3
  m.update({ phase: 'testing', completion: 75, message: 'Running tests' });
  await doTesting();
});
*/
